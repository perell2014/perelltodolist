<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Todo List App â€” Google SSO + jsonbin</title>
    <link rel="icon" type="image/x-icon" href="./images/task.ico">
    <link href="./scripts/font-awesome/css/all.min.css" rel="stylesheet">
    <link href="./scripts/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Google Identity Services (loaded async) -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <!-- SheetJS and jsPDF for export features -->
    <script src="./scripts/ajax/xlsx/xlsx.full.min.js"></script>
    <script src="./scripts/ajax/jspdf/jspdf.umd.min.js"></script>

    <style>
        body { background-color:#f0f0f0; font-size:14px; display:flex; flex-direction:column; min-height:100vh; margin:0 }
        .top-bar { background:#4a90e2; color:#fff; padding:10px 0; box-shadow:0 2px 4px rgba(0,0,0,0.1)}
        .top-bar h1 { font-size:1.8rem; margin:0 }
        .nav-tabs { background:#e9ecef; border-bottom:2px solid #4a90e2 }
        .nav-tabs .nav-link { color: #495057; }
        .nav-tabs .nav-link.active { color:#fff; border: none; }
        .nav-tabs .nav-link[data-tab="pro"].active { background-color: #4a90e2; }
        .nav-tabs .nav-link[data-tab="pers"].active { background-color: #28a745; }
        .nav-tabs .nav-link[data-tab="tmp"].active { background-color: #6c757d; }
        .main-content { 
            flex-grow: 1; 
            padding: 20px 0; 
            display: flex;
            flex-direction: column;
            height: calc(100% - 150px); /* Adjust based on your header/footer height */
        }
        .bottom-bar { background:#333; color:#fff; padding:10px 0; font-size:.9rem; text-align:center }
        .task-list { 
            height: 45vh; 
            min-height: 100px;
            max-height: 80vh;
            overflow-y: auto; 
            border: 1px solid #ccc; 
            padding: 8px; 
            background: #fff; 
            border-radius: 8px;
            resize: vertical;
            overflow: auto;
        }
        .task { 
            cursor: move; 
            padding: 6px; 
            margin-bottom: 6px; 
            background: #f8f9fa; 
            border: 1px solid #dee2e6; 
            border-radius: 4px; 
            user-select: none;
        }
        .task.selected { background:#e0f7fa; border-color:#4dd0e1 }
        .notes { min-height:100px }
        .btn { border-radius:15px; padding:3px 10px; margin:1px; font-size:.8rem }
        .btn-reset { background-color: #ff9800; color: white; border: 1px solid #e68a00; }
        .btn-reset:hover { background-color: #e68a00; color: white; }
        .btn-delete { background-color: #dc3545; color: white; border: 1px solid #c82333; }
        .btn-delete:hover { background-color: #c82333; color: white; }
        .btn-backup { background-color: #17a2b8; color: white; border: 1px solid #138496; }
        .btn-backup:hover { background-color: #138496; color: white; }
        .btn-restore { background-color: #6f42c1; color: white; border: 1px solid #5a32a3; }
        .btn-restore:hover { background-color: #5a32a3; color: white; }
        .hidden { display:none }
    </style>
</head>
<body>

<div class="top-bar">
    <div class="container-fluid">
        <div class="row align-items-center">
            <div class="col-md-4"><h1>Todo List App</h1></div>
            <div class="col-md-8 text-end" id="auth-area">
                <!-- We DO NOT use the automatic g_id_onload auto-init to avoid callback timing issues -->
                <div id="gsi-button-placeholder"></div>
                <div id="user-info" class="d-inline-block ms-3 hidden">
                    <span id="user-name"></span>
                    <button class="btn btn-outline-light ms-2" id="signOutBtn">Sign out</button>
                </div>

                <button class="btn btn-outline-light me-2" id="printBtn">Print to PDF</button>
                <button class="btn btn-outline-light me-2" id="exportBtn">Export Excel</button>
                <button class="btn btn-outline-light me-2" id="backupBtn">Backup</button>
                <button class="btn btn-outline-light me-2" id="restoreBtn">Restore</button>
                <button class="btn btn-outline-light" id="removeCompletedBtn">Remove All Completed Tasks</button>
            </div>
        </div>
    </div>
</div>

<ul class="nav nav-tabs justify-content-center" id="taskTabs">
    <li class="nav-item"><a class="nav-link active" href="#" data-tab="pro">Pro</a></li>
    <li class="nav-item"><a class="nav-link" href="#" data-tab="pers">Pers</a></li>
    <li class="nav-item"><a class="nav-link" href="#" data-tab="tmp">Tmp</a></li>
</ul>

<div class="main-content">
    <div class="container-fluid" id="tab-container"></div>
</div>

<div class="bottom-bar">Created by Perell with support from OpenAI / Claude AI / HackTimer by Turuslan - Nov. 2025 - Version:010</div>

<script>
/*
  Clean, fixed version of the app with export features.
  - Safe GSI init
  - Per-user jsonbin persistence
  - Export to Excel (SheetJS) and Print-to-PDF (jsPDF)
*/

// -----------------------------
// CONFIG - Will be initialized after loading local config
// -----------------------------
let CONFIG = {
    GOOGLE_CLIENT_ID: '',
    JSONBIN_BIN_ID: '',
    JSONBIN_MASTER_KEY: '',
    JSONBIN_BASE: 'https://api.jsonbin.io/v3/b'
};

async function loadConfig() {
    try {
        // First try to fetch config from the server
        const response = await fetch('/api/config');
        if (response.ok) {
            const config = await response.json();
            Object.assign(CONFIG, config);
            console.log('Configuration loaded from server');
        } else {
            throw new Error('Failed to fetch config from server');
        }
    } catch (error) {
        console.log('Falling back to local config:', error.message);
        // In production, these will be set by Cloudflare Pages
        if (typeof GOOGLE_CLIENT_ID !== 'undefined') {
            CONFIG.GOOGLE_CLIENT_ID = GOOGLE_CLIENT_ID;
            CONFIG.JSONBIN_BIN_ID = JSONBIN_BIN_ID;
            CONFIG.JSONBIN_MASTER_KEY = JSONBIN_MASTER_KEY;
        } else {
            // In local development, load from local config file
            try {
                console.log('Loading local config file local.config.js');
                const localConfig = await import('./local.config.js');
                Object.assign(CONFIG, localConfig.default);
                if (CONFIG.GOOGLE_CLIENT_ID !== '') {
                    console.log('GOOGLE_CLIENT_ID is defined from local.config.js: ',CONFIG.GOOGLE_CLIENT_ID.length);
                } else {
                    throw new Error('GOOGLE_CLIENT_ID is not defined from local.config.js');
                }
            } catch (e) {
                console.error('Error loading local config:', e);
                // Fallback to environment variables if available
                if (typeof process !== 'undefined' && process.env) {
                    CONFIG.GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID || '';
                    CONFIG.JSONBIN_BIN_ID = process.env.JSONBIN_BIN_ID || '';
                    CONFIG.JSONBIN_MASTER_KEY = process.env.JSONBIN_MASTER_KEY || '';
               }
               else {
                console.log('No environment variables found');
               }
            }
        }
    }
    
    if (CONFIG.GOOGLE_CLIENT_ID !== '') {
// Initialize the app after config is loaded
    initializeApp();
    } else {
        console.log('Could not retrievee env variables since GOOGLE_CLIENT_ID is not defined');
    }
}

// Initialize the application after config is loaded
function initializeApp() {
    // Create a masked version of CONFIG for logging
    const maskedConfig = {};
    for (const [key, value] of Object.entries(CONFIG)) {
        //console.log('Key:', key, 'Value:', value);
        // Keep first 2 and last 2 characters of the key, mask the middle
        const maskedKey = key.length > 4 
            ? `${key.substring(0, 2)}...${key.substring(key.length - 2)}`
            : '...';
        maskedConfig[maskedKey] = '*****';
    }
    
    console.log('App initialized with masked config:', maskedConfig);
    
    // Your existing initialization code here
    // The original CONFIG remains unchanged for actual use in the application
}

// -----------------------------
// App state
// -----------------------------
let currentTab = 'pro';
let loadedTabs = new Set(); // Track which tabs have been loaded
let tasks = { pro: { now: [], future: [], completed: [] }, pers: { now: [], future: [], completed: [] }, tmp: { now: [], future: [], completed: [] } };
let selectedTask = null;
let timers = {};
let currentUser = null; // { id, email, name }
let jsonbinRecordCache = null;
let tasksModified = false; // Track if tasks have been modified

// Start the application by loading configuration
loadConfig().then(() => {
    // Set up tab switching with save on change - using data-tab attributes
    document.querySelector('[data-tab="pro"]').addEventListener('click', () => switchTab('pro'));
    document.querySelector('[data-tab="pers"]').addEventListener('click', () => switchTab('pers'));
    document.querySelector('[data-tab="tmp"]').addEventListener('click', () => switchTab('tmp'));
    
    // Save on page unload
    window.addEventListener('beforeunload', (event) => {
        if (tasksModified && currentUser) {
            const xhr = new XMLHttpRequest();
            xhr.open('PUT', `${CONFIG.JSONBIN_BASE}/${CONFIG.JSONBIN_BIN_ID}`, false);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.setRequestHeader('X-Master-Key', CONFIG.JSONBIN_MASTER_KEY);
            const record = { ...(jsonbinRecordCache || {}), [currentUser.id]: tasks };
            xhr.send(JSON.stringify(record));
        }
    });

    // Also save when the tab becomes hidden (user switches tabs or minimizes browser)
    document.addEventListener('visibilitychange', async () => {
        if (document.visibilityState === 'hidden' && tasksModified && currentUser) {
            try {
                await saveTasksToJsonBin();
                tasksModified = false;
            } catch (err) {
            console.error('Failed to save on tab switch:', err);
        }
    }
    });
}).catch(console.error);

// Function to handle tab switching with save
async function switchTab(tab) {
    console.log(`ðŸ”„ Switching to tab: ${tab}`);
    
    // Save current tab's state before switching
    if (currentTab && tasksModified && currentUser) {
        await saveTasksToJsonBin().catch(console.error);
        tasksModified = false;
    }
    
    // Switch to new tab
    const previousTab = currentTab;
    currentTab = tab;
    
    // Update tab UI
    document.querySelectorAll('#taskTabs .nav-link').forEach(l => l.classList.remove('active'));
    const link = [...document.querySelectorAll('#taskTabs .nav-link')].find(a => a.dataset.tab === tab);
    if (link) link.classList.add('active');
    
    // Always load tasks if this tab hasn't been loaded yet OR if data appears corrupted
    const needsReload = !loadedTabs.has(tab) || 
                        !tasks[tab] || 
                        !tasks[tab].now || 
                        !tasks[tab].future || 
                        !tasks[tab].completed;
    
    if (needsReload) {
        console.log(`ðŸ“‚ Tab ${tab} needs reload (loaded: ${loadedTabs.has(tab)}, data exists: ${!!tasks[tab]})`);
        await loadTasksForTab(tab);
        loadedTabs.add(tab);
    } else {
        console.log(`ðŸ“‚ Tab ${tab} already loaded, checking for remote updates...`);
        // Always check for remote updates when switching tabs to ensure we have the latest data
        try {
            const record = await fetchJsonBinRecord();
            if (record && record[currentUser.id] && record[currentUser.id][tab]) {
                const remoteTabData = record[currentUser.id][tab];
                // Compare with current data to see if there are updates
                const currentData = JSON.stringify(tasks[tab]);
                const remoteData = JSON.stringify(remoteTabData);
                if (currentData !== remoteData) {
                    console.log(`ðŸ”„ Found remote updates for tab ${tab}, refreshing...`);
                    tasks[tab] = remoteTabData;
                    // Update local storage with the fresh data
                    const local = localStorage.getItem('tasks_' + currentUser.id);
                    const updatedLocal = { ...JSON.parse(local || '{}'), [tab]: tasks[tab] };
                    localStorage.setItem('tasks_' + currentUser.id, JSON.stringify(updatedLocal));
                    console.log(`ðŸ’¾ Updated local storage with fresh jsonbin data for tab ${tab}`);
                } else {
                    console.log(`ðŸ“‚ Tab ${tab} data is up to date, using cached data`);
                }
            } else {
                console.log(`ðŸ“‚ No remote data found for tab ${tab}, using cached data`);
            }
        } catch (e) {
            console.error('Error checking for remote updates for tab', tab, ':', e);
            console.log(`ðŸ“‚ Using cached data for tab ${tab} due to remote check failure`);
        }
    }
    renderTabContent();
}

// -----------------------------
// Helpers
// -----------------------------
function formatTime(s) {
    const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), sec = s%60;
    return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
}
function formatDateTime() { const n=new Date(); return `${String(n.getDate()).padStart(2,'0')}/${String(n.getMonth()+1).padStart(2,'0')}/${String(n.getFullYear()).slice(-2)} ${String(n.getHours()).padStart(2,'0')}:${String(n.getMinutes()).padStart(2,'0')}:${String(n.getSeconds()).padStart(2,'0')}`; }

// Normalize incoming tasks object to guarantee structure
function normalizeTasks(obj) {
    const base = { now: [], future: [], completed: [] };
    obj = obj || {};
    return {
        pro: Object.assign({}, base, obj.pro || {}),
        pers: Object.assign({}, base, obj.pers || {}),
        tmp: Object.assign({}, base, obj.tmp || {})
    };
}

// -----------------------------
// jsonbin.io helpers
// -----------------------------
async function fetchJsonBinRecord() {
    try {
        if (!CONFIG.JSONBIN_BIN_ID || !CONFIG.JSONBIN_MASTER_KEY) {
            console.error('JSONBin configuration missing');
            return null;
        }
        const res = await fetch(`${CONFIG.JSONBIN_BASE}/${CONFIG.JSONBIN_BIN_ID}`, {
            method: 'GET', headers: { 'X-Master-Key': CONFIG.JSONBIN_MASTER_KEY }
        });
        if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
        const data = await res.json();
        const record = data.record || {};
        jsonbinRecordCache = record;
        return record;
    } catch (err) {
        console.error('fetchJsonBinRecord error', err);
        return {};
    }
}

async function saveJsonBinRecord(record) {
    try {
        if (!CONFIG.JSONBIN_BIN_ID || !CONFIG.JSONBIN_MASTER_KEY) {
            throw new Error('JSONBin configuration is missing. Tasks will only be saved locally.');
        }
        const res = await fetch(`${CONFIG.JSONBIN_BASE}/${CONFIG.JSONBIN_BIN_ID}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json', 'X-Master-Key': CONFIG.JSONBIN_MASTER_KEY },
            body: JSON.stringify(record)
        });
        if (!res.ok) {
            const errorText = await res.text();
            throw new Error(`HTTP ${res.status}: ${errorText || 'Unknown error'}`);
        }
        const data = await res.json();
        jsonbinRecordCache = record;
        return data;
    } catch (err) {
        console.error('saveJsonBinRecord error', err);
        // Show user-friendly error message
        alert(`âš ï¸ Warning: Could not save to cloud storage. Your changes are only saved locally.

Error details: ${err.message}

Please check your internet connection and try again.`);
        return null;
    }
}

async function saveTasksToJsonBin() {
    if (!currentUser) return;
    let record = jsonbinRecordCache || await fetchJsonBinRecord();
    record = record || {};
    record[currentUser.id] = tasks;
    return await saveJsonBinRecord(record);
}

// -----------------------------
// Local persistence (per-user)
// -----------------------------
function saveToLocalStorage() {
    if (currentUser) {
        localStorage.setItem('tasks_' + currentUser.id, JSON.stringify(tasks));
    } else {
        localStorage.setItem('tasks', JSON.stringify(tasks));
    }
    tasksModified = true;
}

async function loadTasksForTab(tab) {
    if (!currentUser) return;
    
    console.log(`ðŸ” Loading tasks for tab: ${tab}`);
    
    // show UI
    document.getElementById('tab-container').classList.remove('hidden');
    document.getElementById('taskTabs').classList.remove('hidden');
    
    // load local first for this specific tab
    const local = localStorage.getItem('tasks_' + currentUser.id);
    let localTabData = null;
    if (local) {
        try { 
            const parsed = JSON.parse(local);
            if (parsed && parsed[tab]) {
                localTabData = parsed[tab];
                console.log(`ðŸ“± Found ${Object.keys(localTabData).length} categories in local storage for tab ${tab}`);
                // Update this tab's data from local storage
                if (!tasks[tab]) tasks[tab] = { now: [], future: [], completed: [] };
                tasks[tab] = localTabData;
            } else {
                console.log(`ðŸ“± No local data found for tab ${tab}`);
            }
        } catch(e) { 
            console.warn('local parse error for tab', tab, e); 
        }
    } else {
        console.log(`ðŸ“± No local storage data found for user ${currentUser.id}`);
    }

    try {
        // fetch remote authoritative copy
        console.log(`â˜ï¸ Fetching data from jsonbin for tab ${tab}`);
        const record = await fetchJsonBinRecord();
        if (record && record[currentUser.id] && record[currentUser.id][tab]) {
            // Update this tab's data from jsonbin
            tasks[tab] = record[currentUser.id][tab];
            console.log(`â˜ï¸ Found ${Object.keys(tasks[tab]).length} categories in jsonbin for tab ${tab}`);
            // Update local storage with the fresh data
            const updatedLocal = { ...JSON.parse(local || '{}'), [tab]: tasks[tab] };
            localStorage.setItem('tasks_' + currentUser.id, JSON.stringify(updatedLocal));
            console.log(`ðŸ’¾ Updated local storage with jsonbin data for tab ${tab}`);
        } else {
            console.log(`â˜ï¸ No jsonbin data found for tab ${tab}`);
            if (!localTabData) {
                // No data from jsonbin and no local data, ensure normalized structure
                console.log(`ðŸ†• Creating empty structure for tab ${tab}`);
                if (!tasks[tab]) tasks[tab] = { now: [], future: [], completed: [] };
                // Save the empty structure to jsonbin
                await saveTasksToJsonBin();
            } else {
                console.log(`ðŸ“± Keeping local data for tab ${tab} (no remote data)`);
            }
        }
    } catch (e) {
        console.error('Error loading remote tasks for tab', tab, ':', e);
        // If remote fails, we already have local data loaded above, so keep that
    }
    
    console.log(`âœ… Finished loading tab ${tab}:`, {
        now: tasks[tab]?.now?.length || 0,
        future: tasks[tab]?.future?.length || 0,
        completed: tasks[tab]?.completed?.length || 0
    });
}

async function loadTasksForCurrentUser() {
    if (!currentUser) return;
    
    // show UI
    document.getElementById('tab-container').classList.remove('hidden');
    document.getElementById('taskTabs').classList.remove('hidden');

    // load local first - load ALL tabs data
    const local = localStorage.getItem('tasks_' + currentUser.id);
    if (local) {
        try { 
            const parsed = JSON.parse(local);
            // Load complete tasks structure for all tabs
            tasks = normalizeTasks(parsed);
            console.log('ðŸ“± Loaded all tabs from local storage');
        } catch(e) { 
            console.warn('local parse error', e); 
        }
    }

    try {
        // fetch remote authoritative copy - load ALL tabs data
        const record = await fetchJsonBinRecord();
        if (record && record[currentUser.id]) {
            // Load complete tasks structure for all tabs from remote
            tasks = normalizeTasks(record[currentUser.id]);
            localStorage.setItem('tasks_' + currentUser.id, JSON.stringify(tasks));
            console.log('â˜ï¸ Loaded all tabs from jsonbin');
        } else {
            // ensure normalized and save initial
            tasks = normalizeTasks(tasks);
            await saveTasksToJsonBin();
        }
    } catch (e) {
        console.error('Error loading remote tasks:', e);
    }
    
    // Mark all tabs as loaded since we have the data
    loadedTabs.clear();
    loadedTabs.add('pro');
    loadedTabs.add('pers');
    loadedTabs.add('tmp');
    
    renderTabContent();
}

// -----------------------------
// Google Sign-In handlers
// -----------------------------
function parseJwt (token) {
  const base64Url = token.split('.')[1];
  const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
  const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c){ return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2); }).join(''));
  return JSON.parse(jsonPayload);
}

// Global callback referenced by GSI init
window.handleCredentialResponse = async function(response) {
    if (!CONFIG.GOOGLE_CLIENT_ID) {
        console.error('Google Client ID not configured');
        return;
    }
    try {
        const payload = parseJwt(response.credential);
        currentUser = { id: payload.sub, email: payload.email, name: payload.name };
        console.log(`ðŸ‘¤ User logged in: ${currentUser.name} (${currentUser.email})`);
        document.getElementById('user-name').textContent = `${currentUser.name} (${currentUser.email})`;
        document.getElementById('user-info').classList.remove('hidden');
        document.getElementById('gsi-button-placeholder').classList.add('hidden');
        
        // Load all tabs data using the improved function
        console.log(`ðŸš€ Loading all tabs data for user: ${currentUser.name}`);
        await loadTasksForCurrentUser();
        renderTabContent();
    } catch (err) {
        console.error('handleCredentialResponse error', err);
    }
};

function renderGoogleButtonWhenReady() {
    const maxWaitMs = 5000; // give the GSI script a little time
    const interval = 100;
    let waited = 0;
    return new Promise((resolve, reject) => {
        const t = setInterval(() => {
            if (window.google && google.accounts && google.accounts.id) {
                clearInterval(t);
                try {
                    // initialize GSI with a real function reference (not string)
                    google.accounts.id.initialize({ client_id: CONFIG.GOOGLE_CLIENT_ID, callback: window.handleCredentialResponse });
                    google.accounts.id.renderButton(document.getElementById('gsi-button-placeholder'), { theme: 'outline', size: 'large' });
                    resolve();
                } catch (err) {
                    reject(err);
                }
            }
            waited += interval;
            if (waited > maxWaitMs) { clearInterval(t); reject(new Error('GSI not available')); }
        }, interval);
    });
}

function signOut() {
    currentUser = null; jsonbinRecordCache = null; tasks = normalizeTasks(null);
    document.getElementById('user-info').classList.add('hidden');
    document.getElementById('gsi-button-placeholder').classList.remove('hidden');
    document.getElementById('tab-container').classList.add('hidden');
    document.getElementById('taskTabs').classList.add('hidden');
    stopAllTimers();
}

// -----------------------------
// UI rendering and behavior
// -----------------------------

function renderTabContent() {
    const container = document.getElementById('tab-container');
    container.innerHTML = `
        <div class="row">
            <div class="col-md-4">
                <h2>Now</h2>
                <div id="now-list" class="task-list"></div>
                <button class="btn btn-primary mt-2" id="add-now">Add Task</button>
            </div>
            <div class="col-md-4">
                <h2>Future</h2>
                <div id="future-list" class="task-list"></div>
                <button class="btn btn-primary mt-2" id="add-future">Add Task</button>
            </div>
            <div class="col-md-4">
                <h2>Completed</h2>
                <div id="completed-list" class="task-list"></div>
            </div>
        </div>
        <div class="row mt-4">
            <div class="col-md-12">
                <h3>Notes</h3>
                <textarea id="task-notes" class="form-control notes" placeholder="Task notes..."></textarea>
            </div>
        </div>
    `;

    document.getElementById('add-now').addEventListener('click', () => addTask('now'));
    document.getElementById('add-future').addEventListener('click', () => addTask('future'));
    renderTasks();
    setupDragDrop();
}

function createTaskElement(task, listId) {
    const taskElement = document.createElement('div');
    taskElement.className = 'task';
    taskElement.draggable = true;
    taskElement.dataset.taskId = task.id;

    const nameSpan = document.createElement('span');
    nameSpan.contentEditable = true;
    nameSpan.textContent = task.name || '';
    nameSpan.addEventListener('input', () => updateTaskName(nameSpan, listId, task.id));

    const timerSpan = document.createElement('span');
    timerSpan.className = 'timer';
    timerSpan.textContent = formatTime(task.time || 0);

    taskElement.appendChild(nameSpan);
    taskElement.appendChild(timerSpan);

    if (listId === 'now') {
        const startBtn = document.createElement('button'); startBtn.className = 'btn btn-sm btn-primary start-pause-btn'; startBtn.innerHTML = '<i class="fas fa-play"></i>';
        startBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleStartPause(startBtn, task.id); });
        const resetBtn = document.createElement('button'); resetBtn.className = 'btn btn-reset'; resetBtn.textContent = 'Reset'; resetBtn.addEventListener('click', (e)=>{ e.stopPropagation(); resetTimer(task.id); });
        taskElement.appendChild(startBtn); taskElement.appendChild(resetBtn);
    }

    if (listId !== 'completed') {
        const delBtn = document.createElement('button'); delBtn.className = 'btn btn-delete'; delBtn.textContent = 'Delete'; delBtn.addEventListener('click', (e)=>{ e.stopPropagation(); deleteTask(listId, task.id); });
        taskElement.appendChild(delBtn);
    }

    taskElement.addEventListener('click', () => selectTask(task.id, listId));
    taskElement.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', JSON.stringify({ taskId: task.id, sourceList: listId })); });
    return taskElement;
}

function renderTasks() {
    ['now','future','completed'].forEach(listId => {
        const el = document.getElementById(`${listId}-list`);
        if (!el) return;
        el.innerHTML = '';
        const list = (tasks[currentTab] && tasks[currentTab][listId]) ? tasks[currentTab][listId] : [];
        list.forEach(t => el.appendChild(createTaskElement(t, listId)));
    });
}

function addTask(listId) {
    const taskName = prompt('Enter task name:');
    if (!taskName) return;
    if (!tasks[currentTab]) tasks[currentTab] = { now: [], future: [], completed: [] };
    const newTask = { id: Date.now().toString(), name: taskName, time: 0, notes: '' };
    tasks[currentTab][listId].push(newTask);
    saveToLocalStorage(); renderTasks();
}

function updateTaskName(element, listId, taskId) {
    const list = tasks[currentTab] && tasks[currentTab][listId];
    if (!list) return;
    const task = list.find(t=>t.id===taskId);
    if (task) { task.name = element.textContent.replace(/\n/g,''); saveToLocalStorage(); }
}

function selectTask(taskId, listId) {
    document.querySelectorAll('.task').forEach(t=>t.classList.remove('selected'));
    const list = tasks[currentTab] && tasks[currentTab][listId];
    selectedTask = list ? list.find(t=>t.id===taskId) : null;
    const el = document.querySelector(`.task[data-task-id="${taskId}"]`);
    if (el) el.classList.add('selected');
    const notesEl = document.getElementById('task-notes');
    notesEl.value = selectedTask ? selectedTask.notes || '' : '';
    notesEl.oninput = (e) => { if (selectedTask) { selectedTask.notes = e.target.value; saveToLocalStorage(); } };
}

function deleteTask(listId, taskId) {
    const list = tasks[currentTab] && tasks[currentTab][listId];
    if (!list) return;
    const idx = list.findIndex(t=>t.id===taskId);
    if (idx!==-1) { list.splice(idx,1); if (selectedTask && selectedTask.id===taskId) { selectedTask = null; document.getElementById('task-notes').value=''; } saveToLocalStorage(); renderTasks(); }
}

function removeCompletedTasks() {
    if (!confirm('Remove all completed tasks in current tab?')) return;
    if (tasks[currentTab]) tasks[currentTab].completed = [];
    saveToLocalStorage(); renderTasks();
}

// -----------------------------
// Timers
// -----------------------------
function startTimer(taskId) {
    stopAllTimers();
    const task = tasks[currentTab] && tasks[currentTab].now.find(t=>t.id===taskId);
    if (!task) return;
    timers[taskId] = setInterval(()=>{ task.time = (task.time||0)+1; updateTimerDisplay(taskId); if (task.time%1200===0) playSound('https://s3.amazonaws.com/freecodecamp/drums/Heater-1.mp3'); if (task.time%3600===0){ playSound('https://s3.amazonaws.com/freecodecamp/drums/Heater-2.mp3'); } saveToLocalStorage(); }, 1000);
}
function stopTimer(taskId){ if (timers[taskId]) { clearInterval(timers[taskId]); delete timers[taskId]; } }
function resetTimer(taskId){ stopTimer(taskId); const t = tasks[currentTab] && tasks[currentTab].now.find(x=>x.id===taskId); if (t){ t.time=0; updateTimerDisplay(taskId); saveToLocalStorage(); } }
function stopAllTimers(){ Object.keys(timers).forEach(id=>{ clearInterval(timers[id]); delete timers[id]; }); }
function updateTimerDisplay(taskId){ const t = tasks[currentTab] && tasks[currentTab].now.find(x=>x.id===taskId); if (t){ const el=document.querySelector(`#now-list .task[data-task-id="${taskId}"] .timer`); if (el) el.textContent = formatTime(t.time||0); } }
function toggleStartPause(button, taskId){ const icon = button.querySelector('i'); const isPlaying = icon.classList.contains('fa-pause'); if (isPlaying){ icon.classList.replace('fa-pause','fa-play'); button.classList.replace('btn-danger','btn-primary'); stopTimer(taskId); } else { document.querySelectorAll('.start-pause-btn i.fa-pause').forEach(p=>p.classList.replace('fa-pause','fa-play')); document.querySelectorAll('.start-pause-btn').forEach(b=>b.classList.replace('btn-danger','btn-primary')); icon.classList.replace('fa-play','fa-pause'); button.classList.replace('btn-primary','btn-danger'); startTimer(taskId); } }
function playSound(url){ try{ new Audio(url).play(); }catch(e){console.warn('sound play failed',e);} }

// -----------------------------
// Drag & drop
// -----------------------------
function setupDragDrop(){ ['now','future','completed'].forEach(listId=>{ const el=document.getElementById(`${listId}-list`); if (!el) return; el.addEventListener('dragover', e=>e.preventDefault()); el.addEventListener('drop', e=>{ e.preventDefault(); try{ const {taskId, sourceList} = JSON.parse(e.dataTransfer.getData('text/plain')); const targetList = e.target.closest('.task-list').id.split('-')[0]; const src = tasks[currentTab] && tasks[currentTab][sourceList]; if (!src) return; const idx = src.findIndex(t=>t.id===taskId); if (idx!==-1){ const [task] = src.splice(idx,1); if (targetList==='completed') task.name += ` --Date: ${formatDateTime()}`; tasks[currentTab][targetList].push(task); saveToLocalStorage(); renderTasks(); } }catch(err){ console.error('drop error',err);} }); }); }

// -----------------------------
// Backup and Restore functionality
// -----------------------------
async function backupData() {
    try {
        // Ensure all tabs are loaded before backup
        if (currentUser) {
            console.log('Loading all tabs for backup...');
            for (const tab of ['pro', 'pers', 'tmp']) {
                if (!loadedTabs.has(tab)) {
                    await loadTasksForTab(tab);
                    loadedTabs.add(tab);
                }
            }
            // Switch back to current tab
            await switchTab(currentTab);
        }
        
        // Create backup object with all user data
        const backupData = {
            version: '1.0',
            timestamp: new Date().toISOString(),
            user: currentUser ? {
                id: currentUser.id,
                email: currentUser.email,
                name: currentUser.name
            } : null,
            tasks: tasks,
            currentTab: currentTab
        };
        
        // Convert to JSON and create blob
        const jsonString = JSON.stringify(backupData, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        
        // Create download link
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const filename = `todolist_backup_${currentUser ? currentUser.id : 'anon'}_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.json`;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        
        console.log('Backup created successfully');
    } catch (err) {
        console.error('Backup failed:', err);
        alert('Backup failed: ' + err.message);
    }
}

async function restoreData() {
    try {
        // Create file input element
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.onchange = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const backupData = JSON.parse(text);
                
                // Validate backup structure
                if (!backupData.tasks || typeof backupData.tasks !== 'object') {
                    throw new Error('Invalid backup file structure');
                }
                
                // Confirm restore
                const confirmMessage = `This will completely replace all your current tasks with the backup from ${new Date(backupData.timestamp).toLocaleString()}.\n\nAre you sure you want to continue?`;
                if (!confirm(confirmMessage)) return;
                
                // Restore data
                tasks = normalizeTasks(backupData.tasks);
                if (backupData.currentTab && ['pro', 'pers', 'tmp'].includes(backupData.currentTab)) {
                    currentTab = backupData.currentTab;
                }
                
                // Update UI
                loadedTabs.clear(); // Force reload of all tabs
                await switchTab(currentTab);
                
                // Save to storage
                saveToLocalStorage();
                if (currentUser) {
                    await saveTasksToJsonBin();
                }
                
                console.log('Data restored successfully');
                alert('Data restored successfully!');
            } catch (parseErr) {
                console.error('Restore failed:', parseErr);
                alert('Restore failed: ' + parseErr.message);
            }
        };
        
        // Trigger file selection
        input.click();
    } catch (err) {
        console.error('Restore failed:', err);
        alert('Restore failed: ' + err.message);
    }
}

// -----------------------------
// Export to Excel (SheetJS) and Print-to-PDF (jsPDF)
// Exports all tabs and lists for the current user.
// -----------------------------
async function exportToExcel() {
    try {
        // Build rows: Tab, List, ID, Name, Time, Notes
        const rows = [['Tab','List','ID','Name','Time','Notes']];
        Object.keys(tasks).forEach(tabKey => {
            ['now','future','completed'].forEach(listId => {
                const list = (tasks[tabKey] && tasks[tabKey][listId]) ? tasks[tabKey][listId] : [];
                list.forEach(t => rows.push([tabKey, listId, t.id, t.name || '', formatTime(t.time||0), t.notes || '']));
            });
        });
        const ws = XLSX.utils.aoa_to_sheet(rows);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'Tasks');
        const wbout = XLSX.write(wb, { bookType:'xlsx', type:'array' });
        const blob = new Blob([wbout], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const filename = `tasks_${currentUser ? currentUser.id : 'anon'}_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.xlsx`;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    } catch (err) {
        console.error('exportToExcel error', err);
        alert('Export to Excel failed: ' + err.message);
    }
}

async function printTasks() {
    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ unit: 'pt', format: 'a4' });
        const left = 40;
        let y = 40;
        const lineHeight = 14;
        const pageHeight = doc.internal.pageSize.height - 60;

        const header = `Tasks for ${currentUser ? currentUser.name + ' ('+currentUser.email+')' : 'Anonymous'}`;
        doc.setFontSize(14);
        doc.text(header, left, y);
        y += 20;
        doc.setFontSize(10);

        Object.keys(tasks).forEach(tabKey => {
            // Print tab header
            if (y > pageHeight) { doc.addPage(); y = 40; }
            doc.setFontSize(12);
            doc.text(`Tab: ${tabKey}`, left, y);
            y += 16;
            doc.setFontSize(10);

            ['now','future','completed'].forEach(listId => {
                const list = (tasks[tabKey] && tasks[tabKey][listId]) ? tasks[tabKey][listId] : [];
                if (list.length === 0) return;
                if (y > pageHeight) { doc.addPage(); y = 40; }
                doc.text(`${listId.toUpperCase()} (${list.length})`, left+8, y);
                y += 14;
                list.forEach(t => {
                    const line = `â€¢ ${t.name || '(no name)'} [${formatTime(t.time||0)}]`;
                    const notes = (t.notes || '').replace(/\s+/g,' ');
                    const maxWidth = doc.internal.pageSize.width - left - 40;
                    const split = doc.splitTextToSize(line + (notes?(' â€” ' + notes):''), maxWidth);
                    split.forEach(part => {
                        if (y > pageHeight) { doc.addPage(); y = 40; }
                        doc.text(part, left+16, y);
                        y += lineHeight;
                    });
                });
                y += 6;
            });
            y += 8;
        });

        const filename = `tasks_${currentUser ? currentUser.id : 'anon'}_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.pdf`;
        doc.save(filename);
    } catch (err) {
        console.error('printTasks error', err);
        alert('PDF export failed: ' + err.message);
    }
}

// -----------------------------
// Wiring UI buttons that live outside tab container
// -----------------------------
document.addEventListener('click', (e)=>{
    const target = e.target;
    if (target && target.id === 'signOutBtn') signOut();
});

// Hook buttons
window.addEventListener('DOMContentLoaded', () => {
    // Hide main UI until sign-in
    document.getElementById('tab-container').classList.add('hidden');
    document.getElementById('taskTabs').classList.add('hidden');

    // Tab clicks
    document.querySelectorAll('#taskTabs .nav-link').forEach(link=>{
        link.addEventListener('click', (e)=>{ e.preventDefault(); switchTab(link.dataset.tab); });
    });

    // External buttons
    const exportBtn = document.getElementById('exportBtn');
    if (exportBtn) exportBtn.addEventListener('click', exportToExcel);
    const printBtn = document.getElementById('printBtn');
    if (printBtn) printBtn.addEventListener('click', printTasks);
    const backupBtn = document.getElementById('backupBtn');
    if (backupBtn) backupBtn.addEventListener('click', backupData);
    const restoreBtn = document.getElementById('restoreBtn');
    if (restoreBtn) restoreBtn.addEventListener('click', restoreData);
    document.getElementById('removeCompletedBtn').addEventListener('click', removeCompletedTasks);

    // Initialize Google Sign-in button when GSI is ready
    renderGoogleButtonWhenReady().then(()=>{
        console.info('GSI initialized');
    }).catch(err=>{
        console.warn('GSI unavailable:', err);
        // Show a fallback message or UI
        const ph = document.getElementById('gsi-button-placeholder');
        ph.innerHTML = '<button class="btn btn-outline-light">Sign in (GSI unavailable)</button>';
        ph.querySelector('button').addEventListener('click', ()=>alert('Google Sign-in is unavailable. Check network or origin settings.'));
    });
});

</script>
</body>
</html>
